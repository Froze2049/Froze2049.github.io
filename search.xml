<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web前端知识点整理</title>
      <link href="/posts/4f14/"/>
      <url>/posts/4f14/</url>
      
        <content type="html"><![CDATA[<p>Web 前端知识点整理</p><span id="more"></span><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p><strong>alt 和 title 同时设置的时候，alt 作为图片的替代文字出现，title 是图片的解释文字</strong></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><div class="story post-story"><h2 id="CSS-position-属性"><a href="#CSS-position-属性" class="headerlink" title="CSS position 属性"></a>CSS position 属性</h2><p><a href="https://www.w3school.com.cn/cssref/pr_class_position.asp">https://www.w3school.com.cn/cssref/pr_class_position.asp</a></p><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">absolute</td><td align="left">生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td></tr><tr><td align="left">fixed</td><td align="left">生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td></tr><tr><td align="left">relative</td><td align="left">生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</td></tr><tr><td align="left">static</td><td align="left">默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</td></tr><tr><td align="left">inherit</td><td align="left">规定应该从父元素继承 position 属性的值。</td></tr><tr><td align="left">sticky</td><td align="left">相对定位和固定定位的混合。当元素在屏幕或滚动元素显示区域时，表现为 relative，就要滚出显示器屏幕的时候，表现为 fixed。</td></tr></tbody></table></div><div class="story post-story"><h2 id="CSS-实现三角形"><a href="#CSS-实现三角形" class="headerlink" title="CSS 实现三角形"></a>CSS 实现三角形</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.tri</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.591</span>);</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.591</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/09/19/IOTjWfvE8wVkcBh.png" class="lazyload" data-srcset="https://s2.loli.net/2022/09/19/IOTjWfvE8wVkcBh.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220913215937238.png" style="zoom:67%;" /></div><div class="story post-story"><h2 id="Less-是什么"><a href="#Less-是什么" class="headerlink" title="Less 是什么"></a>Less 是什么</h2><p>一种 CSS 预处理器，可以拥有变量，运算，继承，嵌套的功能，可以使代码更加的便于阅读和维护。</p></div><div class="story post-story"><h2 id="块级元素和行内元素"><a href="#块级元素和行内元素" class="headerlink" title="块级元素和行内元素"></a>块级元素和行内元素</h2><p><strong>常见块级元素：</strong>div , h1—h6 , p , ul , li , ol , dl , table , form</p><p><strong>常见行内元素：</strong>span , a , strong , b , em , i , big , small , label , <strong>img , canvas , input , select ,textarea</strong></p><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1></div><div class="story post-story"><h2 id="es6-语法"><a href="#es6-语法" class="headerlink" title="es6 语法"></a>es6 语法</h2><h3 id="let、const-声明变量"><a href="#let、const-声明变量" class="headerlink" title="let、const 声明变量"></a>let、const 声明变量</h3><h3 id="对象优化"><a href="#对象优化" class="headerlink" title="对象优化"></a>对象优化</h3><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h3 id="map-和-reduce-方法"><a href="#map-和-reduce-方法" class="headerlink" title="map 和 reduce 方法"></a>map 和 reduce 方法</h3><ul><li>map():接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回</li><li>reduce():为数组中的每一个元素依次执行回调函数，不包括数组中被删除或未被赋值的元素</li></ul><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><ul><li>export 命令用于规定模块的对外接口，export 不仅可以导出对象，一切 js 变量都可以导出。比如：基本类型变量、函数、数组、对象</li><li>import 命令用于导入其他模块提供的功能</li></ul></div><div class="story post-story"><h2 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h2><p><a href="https://blog.csdn.net/weixin_44682587/article/details/122191888">https://blog.csdn.net/weixin_44682587/article/details/122191888</a></p><ul><li><strong>全局变量</strong>使用不当，没有及时回收（手动赋值 null）</li><li><strong>遗忘的定时器</strong>：当在某个页面使用了定时器，当该页面销毁时，没有手动去释放清理这些定时器</li><li><strong>使用不当的闭包</strong></li><li><strong>遗漏的 DOM 元素</strong></li><li><strong>网络回调</strong></li></ul></div><div class="story post-story"><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>只要协议、域名、端口有任何一个不同, 都被当作是不同的域。</p><p>JavaScript 跨域解决方案：<br>jsonp 跨域<br>document.domain() 跨子域<br>window.name 跨域</p></div><div class="story post-story"><h2 id="常见的事件触发情况"><a href="#常见的事件触发情况" class="headerlink" title="常见的事件触发情况"></a>常见的事件触发情况</h2><p><a href="https://blog.csdn.net/m17611019131/article/details/113784318">https://blog.csdn.net/m17611019131/article/details/113784318</a></p><pre><code>1. onblur：失去焦点2. onfocus:元素获得焦点。3. 加载事件：    1. onload：一张页面或一幅图像完成加载。4. 鼠标事件：    1. onmousedown    鼠标按钮被按下。    2. onmouseup    鼠标按键被松开。    3. onmousemove    鼠标被移动。    4. onmouseover    鼠标移到某元素之上。    5. onmouseout    鼠标从某元素移开。5. 键盘事件：    1. onkeydown    某个键盘按键被按下。    2. onkeyup        某个键盘按键被松开。    3. onkeypress    某个键盘按键被按下并松开。6. 选择和改变    1. onchange    域的内容被改变。    2. onselect    文本被选中。7. 表单事件：    1. onsubmit    确认按钮被点击。    2. onreset    重置按钮被点击。</code></pre></div><div class="story post-story"><h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><ul><li><p>防抖(debounce)：触发高频事件后 n 秒内函数只会被执行一次（最后一次），如果 n 秒内再次被触发，则重新计算延迟时间。</p></li><li><p>节流(throttle)：高频事件触发，但在 n 秒时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只能有一次生效。所以节流会稀释函数的执行频率。</p></li></ul></div><div class="story post-story"><h2 id="谈谈你对-Promise-的理解"><a href="#谈谈你对-Promise-的理解" class="headerlink" title="谈谈你对 Promise 的理解"></a>谈谈你对 Promise 的理解</h2><p>Promise 是 ES6 新增的语法，是异步编程的一种方案，为了解决 Javascript 回调嵌套过多导致回调地狱（callbackhell）而产生的。</p><p>一个 promise 有三种状态：</p><ul><li>pending:表示初始状态，可以转移到 fullfilled (resolved) 或者 rejected 状态</li><li>fulfilled (resolved) :表示操作成功，不可转移状态</li><li>rejected:表示操作失败，不可转移状态</li><li>必须有一个 then 异步执行方法，then 接受两个参数且必须返回一个 promise：</li></ul><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>希望并行执行多个 promise，并等待所有 promise 都准备就绪。</p><p>例如，并行下载几个 URL，并等到所有内容都下载完毕后再对它们进行处理。</p></div><div class="story post-story"><h2 id="JS-数组去重"><a href="#JS-数组去重" class="headerlink" title="JS 数组去重"></a>JS 数组去重</h2><p><a href="https://segmentfault.com/a/1190000016418021">JavaScript 数组去重的方法（12 种方法，史上最全）</a></p><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1></div><div class="story post-story"><h2 id="vue-父子组件生命周期执行顺序"><a href="#vue-父子组件生命周期执行顺序" class="headerlink" title="vue 父子组件生命周期执行顺序"></a>vue 父子组件生命周期执行顺序</h2><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><p>执行顺序为：<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><p>执行顺序为：<br>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p><h3 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h3><p>执行顺序为：<br>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p></div><div class="story post-story"><h2 id="响应式-ref-、computed-、reactive-的区别"><a href="#响应式-ref-、computed-、reactive-的区别" class="headerlink" title="响应式 ref 、computed 、reactive 的区别"></a>响应式 ref 、computed 、reactive 的区别</h2><p>首先 ref 对比 reactive，ref 和 reactive 都是用来作响应式数据。reactive 只能接收一个引用对象，不可以传递普通类型的数据，比如字符串、数字等，但是 ref 可以，因为 ref 返回的是一个响应式代理对象，这个对象 value 值就是我们的传递参数；所以如果是想代理一个对象或者是数组还是使用 reactive 更合适，如果我们想要代理一个普通类型的值就需要使用 ref 去代理更合理；</p><p>ref 接收数据类型为引用类型时，底层依旧是去调用 reactive，生成 Proxy 实例对象，而接收的数据类型为基本类型数据时，低层仍然使用 Object.definepropty()中的 get 和 set 函数。</p><p>computed 接收一个响应式的对象或者值，并且还可以对这个接收的目标进行操作，但是他本身并不是一个响应式的信息，只不过是对这个响应式的参数进行了追踪，获取和修改的操作。</p></div><div class="story post-story"><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>目标是实现这样一个权限判断，在路由跳转之前，会触发一个函数</p><ul><li>全局前置守卫—— router.beforeEach<ul><li><strong>to(必填)</strong>:即将要进入的目标————通俗来说就是去哪儿</li><li><strong>form(必填)</strong>:当前导航正要离开的路由————通俗来说就是来自哪</li><li>**next(可选)**： 钩子函数，里面定义参数，确认下一步路由要做什么 <code>next(&#39;/&#39;)</code>或者 <code>next(&#123; path: &#39;/&#39; &#125;): </code>跳转到一个不同的地址。</li></ul></li><li>全局解析守卫————router.beforeResolve</li><li>全局后置钩子————router.afterEach</li><li>路由独享的守卫————beforeEnter</li><li>组件内的守卫<ul><li><code>beforeRouteEnter</code> —进入前</li><li><code>beforeRouteUpdate</code> — 路由变化时</li><li><code>beforeRouteLeave</code> — 离开后</li></ul></li></ul><h1 id="网络与浏览器"><a href="#网络与浏览器" class="headerlink" title="网络与浏览器"></a>网络与浏览器</h1></div><div class="story post-story"><h2 id="Http-常见状态码"><a href="#Http-常见状态码" class="headerlink" title="Http 常见状态码"></a>Http 常见状态码</h2><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="left">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="left">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>1xx 信息</p><p><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p><p>2xx 成功</p><ul><li><strong>200 OK</strong></li><li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li><li>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li></ul><p>3xx 重定向</p><ul><li><strong>301 Moved Permanently</strong> ：永久性重定向</li><li><strong>302 Found</strong> ：临时性重定向</li><li>303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li><li>304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li><li>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li></ul><p>4xx 客户端错误</p><ul><li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden</strong> ：请求被拒绝。</li><li><strong>404 Not Found</strong></li></ul><p>5xx 服务器错误</p><ul><li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li><li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><h1 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h1><ul><li><p>雪碧图&#x2F;CSS 精灵<br><a href="https://blog.csdn.net/zzx568900/article/details/125921911">https://blog.csdn.net/zzx568900/article/details/125921911</a></p></li><li><p>lazyload 懒加载<br><a href="https://blog.csdn.net/weixin_41966912/article/details/88580857">https://blog.csdn.net/weixin_41966912/article/details/88580857</a></p></li><li><p>减少 http 请求</p></li><li><p>尽量使用组件化，模块化，工程化管理项</p></li><li><p>适当的使用浏览器进行缓存数据</p></li><li><p>减少 DOM 操作：虚拟 DOM</p></li><li><p>使用 iconFonts 替换图片资源</p></li><li><p>使用 CDN</p></li><li><p>非核心代码异步加载</p></li><li><p>防抖、节流</p></li><li><p>延迟加载组件，预加载组件</p></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理期末笔记</title>
      <link href="/posts/53f/"/>
      <url>/posts/53f/</url>
      
        <content type="html"><![CDATA[<p>使用的教材是高等教育出版社的《编译原理（第三版）》陈易云 张昱编著</p><span id="more"></span><div class="story post-story"><h2 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a><strong>第一章：绪论</strong></h2><h3 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a><strong>编译程序</strong></h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><ul><li><p>翻译程序：完成从一种语言到另一种语言的保语义变换的软件</p></li><li><p>源语言：变换前的语言</p></li><li><p>目标语言：变换后的语言</p></li><li><p>编译程序是一种<strong>翻译程序</strong>，将源程序的语句<strong>一次全部翻译成机器语言程序（先翻译成汇编），而后再执行机器语言程序(只需翻译一次)</strong> </p></li><li><p>解释程序：将源程序的语句翻译一句执行一句(每次执行都要翻译)<strong>，</strong>不会生成目标程序。</p></li></ul><h4 id="画出编译程序的总体结构图，简述个部分的主要功能"><a href="#画出编译程序的总体结构图，简述个部分的主要功能" class="headerlink" title="画出编译程序的总体结构图，简述个部分的主要功能"></a><strong>画出编译程序的总体结构图，简述个部分的主要功能</strong></h4><img src="https://s2.loli.net/2022/06/11/rNlhf9b7ycw1LQW.png" class="lazyload" data-srcset="https://s2.loli.net/2022/06/11/rNlhf9b7ycw1LQW.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png" style="zoom: 65%;" /><p>一个典型的编译程序通常包含8个组成部分，它们是<strong>词法分析</strong>程序、<strong>语法分析</strong>程序、<strong>语义分析</strong>程序、<strong>中间代码生成</strong>程序、中间<strong>代码优化</strong>程序、目标<strong>代码生成</strong>程序、<strong>符号表管理</strong>程序和<strong>错误处理</strong>程序。其各部分的主要功能简述如下。</p><ul><li><strong>词法分析</strong>程序：输人源程序，拼单词、检查单词和分析单词，输出单词的机内表达形式。</li><li><strong>语法分析</strong>程序：检查源程序中存在的形式语法错误，输出错误处理信息。</li><li><strong>语义分析</strong>程序：进行语义检查和分析语义信息，并把分析的结果保存到各类语义信息表中。</li><li><strong>中间代码生成</strong>程序：按照语义规则，将语法分析程序分析出的语法单位转换成一定形式的中间语言代码，如三元式或四元式。</li><li>中间<strong>代码优化</strong>程序：为了产生高质量的目标代码，对中间代码进行等价变换处理。</li><li>目标<strong>代码生成</strong>程序：将优化后的中间代码程序转换成目标代码程序。</li><li><strong>符号表管理</strong>程序：负责建立、填写和查找等一系列表格工作。</li><li><strong>错误处理</strong>程序：处理和校正源程序中存在的词法、语法和语义错误。</li></ul></div><div class="story post-story"><h2 id="第二章：词法分析"><a href="#第二章：词法分析" class="headerlink" title="第二章：词法分析"></a><strong>第二章：词法分析</strong></h2><h3 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a><strong>有限自动机</strong></h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><strong>概念</strong></h4><ul><li><p>不确定的有限自动机（NFA）：</p><p>（1）有限的状态集合S</p><p>（2）输入符号字母表的集合∑</p><p>（3）状态转换函数move：S×(∑∪{ε})→P(S)的部分映射</p><p>（4）状态S0是唯一的开始状态</p><p>（5）终止状态集合F，F⊆S</p></li><li><p>确定的有限自动机（DFA）:</p><p>（1）有限的状态集合S</p><p>（2）输入符号字母表的集合∑</p><p>（3）状态转换函数move：S×∑→S的单值部分映射</p><p>（4）状态S0是唯一的开始状态</p><p>（5）终止状态集合F，F⊆S</p></li></ul><h4 id="正规式构造NFA"><a href="#正规式构造NFA" class="headerlink" title="正规式构造NFA"></a><strong>正规式构造NFA</strong></h4><p><img src="https://s2.loli.net/2022/06/11/1nmTlrhPVgZoOfN.png" class="lazyload" data-srcset="https://s2.loli.net/2022/06/11/1nmTlrhPVgZoOfN.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="v2-898e5775bb068df21403c0baf7ee9035_r.png"></p><h4 id="NFA到DFA的转化"><a href="#NFA到DFA的转化" class="headerlink" title="NFA到DFA的转化"></a><strong>NFA到DFA的转化</strong></h4><p>参考：<a href="https://blog.csdn.net/lilongsy/article/details/82465395">https://blog.csdn.net/lilongsy/article/details/82465395</a></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a><strong>例题</strong></h4><ol><li><p><img src="https://s2.loli.net/2022/06/13/wq5IdZhsazoJjr9.png" class="lazyload" data-srcset="https://s2.loli.net/2022/06/13/wq5IdZhsazoJjr9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Snipaste_2022-06-13_01-24-15.png"></p></li><li><p><img src="https://s2.loli.net/2022/06/13/C8jKumX2YeznfrH.png" class="lazyload" data-srcset="https://s2.loli.net/2022/06/13/C8jKumX2YeznfrH.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Snipaste_2022-06-13_13-00-41.png"></p></li><li><p>构造正规式相应的DFA：1(0|1)*101<br>按照以下三步：<br>（1）由正规表达式构造转换系统（NFA）<br>（2）由转换系统（NFA）构造确定的有穷自动机DFA<br>（3）DFA的最小化</p><p>(0|1)*可以化为</p><img src="https://s2.loli.net/2022/06/11/u4OBctarz2MQ9Jn.png" class="lazyload" data-srcset="https://s2.loli.net/2022/06/11/u4OBctarz2MQ9Jn.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Snipaste_2022-06-11_21-16-19.png" style="zoom: 50%;" /><p>参考解题过程：<a href="https://wenku.baidu.com/view/1076bb15c281e53a5802ff35.html">https://wenku.baidu.com/view/1076bb15c281e53a5802ff35.html</a></p><p>DFA的最小化（化简）：<a href="https://www.bilibili.com/video/BV1J64y1k7nk?p=5">https://www.bilibili.com/video/BV1J64y1k7nk?p=5</a></p></li></ol></div><div class="story post-story"><h2 id="第三章：语法分析"><a href="#第三章：语法分析" class="headerlink" title="第三章：语法分析"></a><strong>第三章：语法分析</strong></h2><h3 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a><strong>上下文无关文法</strong></h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a><strong>概念</strong></h4><ul><li><p>若一个形式文法G &#x3D; (V, Σ, P, S) 的产生式规则都取如下的形式：A <code>-&gt;</code> <em>α</em>，则谓之。其中 A∈V ，<em>α</em>∈(V∪Σ)* 。上下文无关文法取名为“上下文无关”的原因就是因为字符 A 总可以被字符串 α 自由替换，而<strong>无需考虑字符 A 出现的上下文</strong>。</p></li><li><p>上下文无关语法G是一个四元组（VT，VN，S，P），其中包括</p><p>VT：<strong>终结符号</strong>的一组非空有限集合</p><p>VN：<strong>非终结符号</strong>的一组非空有限集合，且VT∩VN&#x3D;∅</p><p>S：一个非终结符，称为<strong>开始符号</strong></p><p>P：<strong>产生式</strong>的有限集合，每个产生式的形式是A→<em>α</em>，A∈VN，<em>α</em>∈(VT∪VN)*。</p></li></ul><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a><strong>例题</strong></h4><ol><li><p>考虑文法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S -&gt; (L)|a</span><br><span class="line">L -&gt; L,S|S</span><br></pre></td></tr></table></figure><p>(a) 建立句子(a,(a,a))和(a,((a,a),(a,a)))的分析树<br>(b) 为(a)的两个句子构造最左推导<br>(c) 为(a)的两个句子构造最右推导<br>(d) 这个文法产生的语言是什么</p><img src="https://s2.loli.net/2022/06/11/xoY6f3gBA5IdlEC.png" class="lazyload" data-srcset="https://s2.loli.net/2022/06/11/xoY6f3gBA5IdlEC.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Snipaste_2022-06-11_14-46-35.png" style="zoom: 49%;" /><img src="https://s2.loli.net/2022/06/11/alnqke4MOhQrRS8.png" class="lazyload" data-srcset="https://s2.loli.net/2022/06/11/alnqke4MOhQrRS8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Snipaste_2022-06-11_14-46-54.png" style="zoom: 45%;" /><p>描述的语言：括号匹配的串_串中的各项由“,”隔开，项可以是括号匹配的子串或a</p></li><li><p>对于文法G(E):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E = T|E+T </span><br><span class="line">T = F|T*F </span><br><span class="line">F = (E)|i </span><br></pre></td></tr></table></figure><p>1）写出句型(T*F+i)的最左推导并画出语法树。</p><p>2）写出上述句型的短语，直接短语和句柄</p><p>短语有T*F+i, T*F, i，直接短语的为 T*F、i，句柄是T*F.</p></li></ol><h3 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a><strong>左递归</strong></h3><ul><li><p>在二元表达式的语法规则中，如果产生式的第一个元素是它自身，那么程序就会无限地递归下去，这种情况就叫做<strong>左递归</strong>。</p></li><li><p>存在递归产生式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A → Aα|β</span><br></pre></td></tr></table></figure><p>消除直接左递归可以写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A → βA’</span><br><span class="line">A’ → αA’|ε</span><br></pre></td></tr></table></figure></li></ul><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a><strong>例题</strong></h4><p>消除下面文法的左递归</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) E → E+T|T</span><br><span class="line">2) T → T*F|F</span><br><span class="line">3) F → (E)|id</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) E → TE’</span><br><span class="line">E’ → +TE’|ε</span><br><span class="line">2)T → FT’</span><br><span class="line">T’ → *FT’|ε</span><br><span class="line">3)F → (E)|id</span><br></pre></td></tr></table></figure><h3 id="自上而下分析"><a href="#自上而下分析" class="headerlink" title="自上而下分析"></a><strong>自上而下分析</strong></h3><h4 id="LL-1"><a href="#LL-1" class="headerlink" title="LL(1)"></a><strong>LL(1)</strong></h4><p>求FIRST集和FOLLOW集：</p><img src="https://s2.loli.net/2022/06/13/75awyDdSoqYL6ft.png" class="lazyload" data-srcset="https://s2.loli.net/2022/06/13/75awyDdSoqYL6ft.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Snipaste_2022-06-13_00-48-25.png" style="zoom:80%;" /><p>求SELECT集：</p><p>(1)式子E的右边第一个T是非终结符，则SELECT(E)&#x3D;FIRST(T)</p><p>(2)E’的右边第一个+是终结符，则加入SELECT(E’)中</p><p>(3)E’的右边第一个是ε符号，则将FOLLOW(E’)加入SELECT(E’)中</p><img src="https://s2.loli.net/2022/06/13/JsBxVb92QdkTZLv.png" class="lazyload" data-srcset="https://s2.loli.net/2022/06/13/JsBxVb92QdkTZLv.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Snipaste_2022-06-13_01-00-14.png" style="zoom: 62%;" /><h3 id="自下而上分析"><a href="#自下而上分析" class="headerlink" title="自下而上分析"></a><strong>自下而上分析</strong></h3><h4 id="LR-0"><a href="#LR-0" class="headerlink" title="LR(0)"></a><strong>LR(0)</strong></h4><p><img src="https://s2.loli.net/2022/06/13/1enKjyWhS8UQqZo.png" class="lazyload" data-srcset="https://s2.loli.net/2022/06/13/1enKjyWhS8UQqZo.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Snipaste_2022-06-13_11-35-30.png"></p><h4 id="SLR-1"><a href="#SLR-1" class="headerlink" title="SLR(1)"></a><strong>SLR(1)</strong></h4><img src="https://s2.loli.net/2022/06/13/KCPvVaix3IyMqhj.png" class="lazyload" data-srcset="https://s2.loli.net/2022/06/13/KCPvVaix3IyMqhj.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Snipaste_2022-06-13_11-38-06.png" style="zoom:80%;" /><img src="https://s2.loli.net/2022/06/13/cKi8sGZP1JNvItS.png" class="lazyload" data-srcset="https://s2.loli.net/2022/06/13/cKi8sGZP1JNvItS.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Snipaste_2022-06-13_11-39-02.png" style="zoom: 70%;" /></div>]]></content>
      
      
      <categories>
          
          <category> 计算机笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单记录配置主题的过程</title>
      <link href="/posts/1166/"/>
      <url>/posts/1166/</url>
      
        <content type="html"><![CDATA[<p>记录一下配置主题的过程和走的弯路</p><span id="more"></span><h3 id="使用npm安装插件需要注意的地方"><a href="#使用npm安装插件需要注意的地方" class="headerlink" title="使用npm安装插件需要注意的地方"></a>使用npm安装插件需要注意的地方</h3><p>npm的包安装分为两种</p><ul><li><p>本地安装（local） </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx </span><br></pre></td></tr></table></figure><p>安装到命令行所在目录的node_module目录</p></li><li><p>全局安装（global）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx  -g</span><br></pre></td></tr></table></figure><p>安装到 \AppData\Roaming\npm\node_modules（默认目录）</p></li></ul><p>由于本人过于小白，打开命令行就直接输入命令npm install xxx，导致插件都安装在了打开命令行时的默认路径下，hexo generata时无法调用插件，期间npm多次报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">51 vulnerabilities (3 low, 17 moderate, 28 high, 3 critical)</span><br><span class="line">To address issues that do not require attention, run:</span><br></pre></td></tr></table></figure><p>搜索出来的解决方法也都无用，<psw>这么蠢的错误毕竟也没有人会犯。</psw>折腾了好久才反应过来。</p><p>总结，<strong>安装插件时请在自己博客根目录内打开命令行</strong>。</p><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>在博客文件夹的根目录创建文件_config.volantis.yml</p><h3 id="配置封面"><a href="#配置封面" class="headerlink" title="配置封面"></a>配置封面</h3><p>在_config.volantis.yml中</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="attr">background:</span> <span class="string">https://s1.ax1x.com/2022/06/08/Xr33lt.jpg</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">&quot;veron&#x27;s blog&quot;</span></span><br></pre></td></tr></table></figure><h3 id="配置背景图片不随文章滚动"><a href="#配置背景图片不随文章滚动" class="headerlink" title="配置背景图片不随文章滚动"></a>配置背景图片不随文章滚动</h3><p>在_config.volantis.yml中</p><p>position设置为fixed</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="attr">parallax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">fixed</span> <span class="comment"># cover: sticky on the cover.   fixed: Fixed as background for the site.</span></span><br><span class="line">    <span class="attr">shuffle:</span> <span class="literal">true</span> <span class="comment"># shuffle playlist</span></span><br><span class="line">    <span class="attr">duration:</span> <span class="number">10000</span> <span class="comment"># Duration (ms)</span></span><br><span class="line">    <span class="attr">fade:</span> <span class="number">500</span> <span class="comment"># fade duration (ms) (Not more than 1500)</span></span><br><span class="line">    <span class="attr">images:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://s1.ax1x.com/2022/06/08/Xr33lt.jpg</span></span><br></pre></td></tr></table></figure><p>注意，开启parallax之后，只需要在images中配置图片就好了，cover中的background不用配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="attr">background:</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">&quot;veron&#x27;s blog&quot;</span></span><br></pre></td></tr></table></figure><h3 id="配置文章内的版权声明组件"><a href="#配置文章内的版权声明组件" class="headerlink" title="配置文章内的版权声明组件"></a>配置文章内的版权声明组件</h3><p>在_config.yml中</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://froze2049.github.io/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Volantis </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
