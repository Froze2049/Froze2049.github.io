{"meta":{"title":"vernon's blog","subtitle":"","description":"vernon's blog.","author":"John Doe","url":"https://froze2049.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2022-06-09T13:36:47.746Z","updated":"2022-06-09T13:36:47.746Z","comments":true,"path":"categories/index.html","permalink":"https://froze2049.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-06-08T09:27:27.345Z","updated":"2022-06-08T09:27:27.345Z","comments":true,"path":"about/index.html","permalink":"https://froze2049.github.io/about/index.html","excerpt":"","text":"test"},{"title":"所有标签","date":"2022-06-09T13:37:13.400Z","updated":"2022-06-09T13:37:13.400Z","comments":true,"path":"tags/index.html","permalink":"https://froze2049.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Web前端知识点整理","slug":"Web前端知识点整理","date":"2022-07-11T14:08:03.000Z","updated":"2022-10-12T14:56:58.826Z","comments":true,"path":"posts/4f14/","link":"","permalink":"https://froze2049.github.io/posts/4f14/","excerpt":"Web 前端知识点整理","text":"Web 前端知识点整理 HTMLalt 和 title 同时设置的时候，alt 作为图片的替代文字出现，title 是图片的解释文字 CSSCSS position 属性https://www.w3school.com.cn/cssref/pr_class_position.asp 值 描述 absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 relative 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 inherit 规定应该从父元素继承 position 属性的值。 sticky 相对定位和固定定位的混合。当元素在屏幕或滚动元素显示区域时，表现为 relative，就要滚出显示器屏幕的时候，表现为 fixed。 CSS 实现三角形1234567div.tri &#123; width: 0; height: 0; border: 100px solid transparent; border-bottom: 100px solid rgba(255, 0, 0, 0.591); border-left: 100px solid rgba(255, 0, 0, 0.591);&#125; Less 是什么一种 CSS 预处理器，可以拥有变量，运算，继承，嵌套的功能，可以使代码更加的便于阅读和维护。 块级元素和行内元素常见块级元素：div , h1—h6 , p , ul , li , ol , dl , table , form 常见行内元素：span , a , strong , b , em , i , big , small , label , img , canvas , input , select ,textarea JavaScriptes6 语法let、const 声明变量对象优化箭头函数map 和 reduce 方法 map():接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回 reduce():为数组中的每一个元素依次执行回调函数，不包括数组中被删除或未被赋值的元素 模块化 export 命令用于规定模块的对外接口，export 不仅可以导出对象，一切 js 变量都可以导出。比如：基本类型变量、函数、数组、对象 import 命令用于导入其他模块提供的功能 内存泄漏的原因https://blog.csdn.net/weixin_44682587/article/details/122191888 全局变量使用不当，没有及时回收（手动赋值 null） 遗忘的定时器：当在某个页面使用了定时器，当该页面销毁时，没有手动去释放清理这些定时器 使用不当的闭包 遗漏的 DOM 元素 网络回调 跨域问题只要协议、域名、端口有任何一个不同, 都被当作是不同的域。 JavaScript 跨域解决方案：jsonp 跨域document.domain() 跨子域window.name 跨域 常见的事件触发情况https://blog.csdn.net/m17611019131/article/details/113784318 1. onblur：失去焦点 2. onfocus:元素获得焦点。 3. 加载事件： 1. onload：一张页面或一幅图像完成加载。 4. 鼠标事件： 1. onmousedown 鼠标按钮被按下。 2. onmouseup 鼠标按键被松开。 3. onmousemove 鼠标被移动。 4. onmouseover 鼠标移到某元素之上。 5. onmouseout 鼠标从某元素移开。 5. 键盘事件： 1. onkeydown 某个键盘按键被按下。 2. onkeyup 某个键盘按键被松开。 3. onkeypress 某个键盘按键被按下并松开。 6. 选择和改变 1. onchange 域的内容被改变。 2. onselect 文本被选中。 7. 表单事件： 1. onsubmit 确认按钮被点击。 2. onreset 重置按钮被点击。 防抖和节流 防抖(debounce)：触发高频事件后 n 秒内函数只会被执行一次（最后一次），如果 n 秒内再次被触发，则重新计算延迟时间。 节流(throttle)：高频事件触发，但在 n 秒时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只能有一次生效。所以节流会稀释函数的执行频率。 谈谈你对 Promise 的理解Promise 是 ES6 新增的语法，是异步编程的一种方案，为了解决 Javascript 回调嵌套过多导致回调地狱（callbackhell）而产生的。 一个 promise 有三种状态： pending:表示初始状态，可以转移到 fullfilled (resolved) 或者 rejected 状态 fulfilled (resolved) :表示操作成功，不可转移状态 rejected:表示操作失败，不可转移状态 必须有一个 then 异步执行方法，then 接受两个参数且必须返回一个 promise： Promise.all希望并行执行多个 promise，并等待所有 promise 都准备就绪。 例如，并行下载几个 URL，并等到所有内容都下载完毕后再对它们进行处理。 JS 数组去重JavaScript 数组去重的方法（12 种方法，史上最全） Vuevue 父子组件生命周期执行顺序挂载阶段执行顺序为：父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted 更新阶段执行顺序为：父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated 销毁阶段执行顺序为：父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed 响应式 ref 、computed 、reactive 的区别首先 ref 对比 reactive，ref 和 reactive 都是用来作响应式数据。reactive 只能接收一个引用对象，不可以传递普通类型的数据，比如字符串、数字等，但是 ref 可以，因为 ref 返回的是一个响应式代理对象，这个对象 value 值就是我们的传递参数；所以如果是想代理一个对象或者是数组还是使用 reactive 更合适，如果我们想要代理一个普通类型的值就需要使用 ref 去代理更合理； ref 接收数据类型为引用类型时，底层依旧是去调用 reactive，生成 Proxy 实例对象，而接收的数据类型为基本类型数据时，低层仍然使用 Object.definepropty()中的 get 和 set 函数。 computed 接收一个响应式的对象或者值，并且还可以对这个接收的目标进行操作，但是他本身并不是一个响应式的信息，只不过是对这个响应式的参数进行了追踪，获取和修改的操作。 路由守卫目标是实现这样一个权限判断，在路由跳转之前，会触发一个函数 全局前置守卫—— router.beforeEach to(必填):即将要进入的目标————通俗来说就是去哪儿 form(必填):当前导航正要离开的路由————通俗来说就是来自哪 **next(可选)**： 钩子函数，里面定义参数，确认下一步路由要做什么 next(&#39;/&#39;)或者 next(&#123; path: &#39;/&#39; &#125;): 跳转到一个不同的地址。 全局解析守卫————router.beforeResolve 全局后置钩子————router.afterEach 路由独享的守卫————beforeEnter 组件内的守卫 beforeRouteEnter —进入前 beforeRouteUpdate — 路由变化时 beforeRouteLeave — 离开后 网络与浏览器Http 常见状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 1xx 信息 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 2xx 成功 200 OK 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。 3xx 重定向 301 Moved Permanently ：永久性重定向 302 Found ：临时性重定向 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。 4xx 客户端错误 400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden ：请求被拒绝。 404 Not Found 5xx 服务器错误 500 Internal Server Error ：服务器正在执行请求时发生错误。 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 前端性能优化 雪碧图&#x2F;CSS 精灵https://blog.csdn.net/zzx568900/article/details/125921911 lazyload 懒加载https://blog.csdn.net/weixin_41966912/article/details/88580857 减少 http 请求 尽量使用组件化，模块化，工程化管理项 适当的使用浏览器进行缓存数据 减少 DOM 操作：虚拟 DOM 使用 iconFonts 替换图片资源 使用 CDN 非核心代码异步加载 防抖、节流 延迟加载组件，预加载组件","categories":[{"name":"计算机笔记","slug":"计算机笔记","permalink":"https://froze2049.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://froze2049.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"编译原理期末笔记","slug":"编译原理期末笔记","date":"2022-06-11T07:18:04.000Z","updated":"2022-07-11T14:09:32.603Z","comments":true,"path":"posts/53f/","link":"","permalink":"https://froze2049.github.io/posts/53f/","excerpt":"使用的教材是高等教育出版社的《编译原理（第三版）》陈易云 张昱编著","text":"使用的教材是高等教育出版社的《编译原理（第三版）》陈易云 张昱编著 第一章：绪论编译程序概念 翻译程序：完成从一种语言到另一种语言的保语义变换的软件 源语言：变换前的语言 目标语言：变换后的语言 编译程序是一种翻译程序，将源程序的语句一次全部翻译成机器语言程序（先翻译成汇编），而后再执行机器语言程序(只需翻译一次) 解释程序：将源程序的语句翻译一句执行一句(每次执行都要翻译)，不会生成目标程序。 画出编译程序的总体结构图，简述个部分的主要功能 一个典型的编译程序通常包含8个组成部分，它们是词法分析程序、语法分析程序、语义分析程序、中间代码生成程序、中间代码优化程序、目标代码生成程序、符号表管理程序和错误处理程序。其各部分的主要功能简述如下。 词法分析程序：输人源程序，拼单词、检查单词和分析单词，输出单词的机内表达形式。 语法分析程序：检查源程序中存在的形式语法错误，输出错误处理信息。 语义分析程序：进行语义检查和分析语义信息，并把分析的结果保存到各类语义信息表中。 中间代码生成程序：按照语义规则，将语法分析程序分析出的语法单位转换成一定形式的中间语言代码，如三元式或四元式。 中间代码优化程序：为了产生高质量的目标代码，对中间代码进行等价变换处理。 目标代码生成程序：将优化后的中间代码程序转换成目标代码程序。 符号表管理程序：负责建立、填写和查找等一系列表格工作。 错误处理程序：处理和校正源程序中存在的词法、语法和语义错误。 第二章：词法分析有限自动机概念 不确定的有限自动机（NFA）： （1）有限的状态集合S （2）输入符号字母表的集合∑ （3）状态转换函数move：S×(∑∪{ε})→P(S)的部分映射 （4）状态S0是唯一的开始状态 （5）终止状态集合F，F⊆S 确定的有限自动机（DFA）: （1）有限的状态集合S （2）输入符号字母表的集合∑ （3）状态转换函数move：S×∑→S的单值部分映射 （4）状态S0是唯一的开始状态 （5）终止状态集合F，F⊆S 正规式构造NFA NFA到DFA的转化参考：https://blog.csdn.net/lilongsy/article/details/82465395 例题 构造正规式相应的DFA：1(0|1)*101按照以下三步：（1）由正规表达式构造转换系统（NFA）（2）由转换系统（NFA）构造确定的有穷自动机DFA（3）DFA的最小化 (0|1)*可以化为 参考解题过程：https://wenku.baidu.com/view/1076bb15c281e53a5802ff35.html DFA的最小化（化简）：https://www.bilibili.com/video/BV1J64y1k7nk?p=5 第三章：语法分析上下文无关文法概念 若一个形式文法G &#x3D; (V, Σ, P, S) 的产生式规则都取如下的形式：A -&gt; α，则谓之。其中 A∈V ，α∈(V∪Σ)* 。上下文无关文法取名为“上下文无关”的原因就是因为字符 A 总可以被字符串 α 自由替换，而无需考虑字符 A 出现的上下文。 上下文无关语法G是一个四元组（VT，VN，S，P），其中包括 VT：终结符号的一组非空有限集合 VN：非终结符号的一组非空有限集合，且VT∩VN&#x3D;∅ S：一个非终结符，称为开始符号 P：产生式的有限集合，每个产生式的形式是A→α，A∈VN，α∈(VT∪VN)*。 例题 考虑文法 12S -&gt; (L)|aL -&gt; L,S|S (a) 建立句子(a,(a,a))和(a,((a,a),(a,a)))的分析树(b) 为(a)的两个句子构造最左推导(c) 为(a)的两个句子构造最右推导(d) 这个文法产生的语言是什么 描述的语言：括号匹配的串_串中的各项由“,”隔开，项可以是括号匹配的子串或a 对于文法G(E): 123E = T|E+T T = F|T*F F = (E)|i 1）写出句型(T*F+i)的最左推导并画出语法树。 2）写出上述句型的短语，直接短语和句柄 短语有T*F+i, T*F, i，直接短语的为 T*F、i，句柄是T*F. 左递归 在二元表达式的语法规则中，如果产生式的第一个元素是它自身，那么程序就会无限地递归下去，这种情况就叫做左递归。 存在递归产生式 1A → Aα|β 消除直接左递归可以写为 12A → βA’A’ → αA’|ε 例题消除下面文法的左递归 1231) E → E+T|T2) T → T*F|F3) F → (E)|id 结果 123451) E → TE’ E’ → +TE’|ε2) T → FT’ T’ → *FT’|ε3) F → (E)|id 自上而下分析LL(1)求FIRST集和FOLLOW集： 求SELECT集： (1)式子E的右边第一个T是非终结符，则SELECT(E)&#x3D;FIRST(T) (2)E’的右边第一个+是终结符，则加入SELECT(E’)中 (3)E’的右边第一个是ε符号，则将FOLLOW(E’)加入SELECT(E’)中 自下而上分析LR(0) SLR(1)","categories":[{"name":"计算机笔记","slug":"计算机笔记","permalink":"https://froze2049.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://froze2049.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"简单记录配置主题的过程","slug":"简单记录配置主题的过程","date":"2022-06-07T14:07:01.000Z","updated":"2022-06-10T07:31:46.576Z","comments":true,"path":"posts/1166/","link":"","permalink":"https://froze2049.github.io/posts/1166/","excerpt":"记录一下配置主题的过程和走的弯路","text":"记录一下配置主题的过程和走的弯路 使用npm安装插件需要注意的地方npm的包安装分为两种 本地安装（local） 1npm install xxx 安装到命令行所在目录的node_module目录 全局安装（global） 1npm install xxx -g 安装到 \\AppData\\Roaming\\npm\\node_modules（默认目录） 由于本人过于小白，打开命令行就直接输入命令npm install xxx，导致插件都安装在了打开命令行时的默认路径下，hexo generata时无法调用插件，期间npm多次报错 1251 vulnerabilities (3 low, 17 moderate, 28 high, 3 critical)To address issues that do not require attention, run: 搜索出来的解决方法也都无用，这么蠢的错误毕竟也没有人会犯。折腾了好久才反应过来。 总结，安装插件时请在自己博客根目录内打开命令行。 创建配置文件在博客文件夹的根目录创建文件_config.volantis.yml 配置封面在_config.volantis.yml中 123cover: background: https://s1.ax1x.com/2022/06/08/Xr33lt.jpg title: &quot;veron&#x27;s blog&quot; 配置背景图片不随文章滚动在_config.volantis.yml中 position设置为fixed 123456789plugins: parallax: enable: true position: fixed # cover: sticky on the cover. fixed: Fixed as background for the site. shuffle: true # shuffle playlist duration: 10000 # Duration (ms) fade: 500 # fade duration (ms) (Not more than 1500) images: - https://s1.ax1x.com/2022/06/08/Xr33lt.jpg 注意，开启parallax之后，只需要在images中配置图片就好了，cover中的background不用配置 123cover: background: title: &quot;veron&#x27;s blog&quot; 配置文章内的版权声明组件在_config.yml中 12345# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://froze2049.github.io/permalink: posts/:abbrlink/permalink_defaults:","categories":[{"name":"博客","slug":"博客","permalink":"https://froze2049.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Volantis","slug":"Volantis","permalink":"https://froze2049.github.io/tags/Volantis/"},{"name":"Hexo","slug":"Hexo","permalink":"https://froze2049.github.io/tags/Hexo/"}]}],"categories":[{"name":"计算机笔记","slug":"计算机笔记","permalink":"https://froze2049.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AC%94%E8%AE%B0/"},{"name":"博客","slug":"博客","permalink":"https://froze2049.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://froze2049.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"编译原理","slug":"编译原理","permalink":"https://froze2049.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"Volantis","slug":"Volantis","permalink":"https://froze2049.github.io/tags/Volantis/"},{"name":"Hexo","slug":"Hexo","permalink":"https://froze2049.github.io/tags/Hexo/"}]}